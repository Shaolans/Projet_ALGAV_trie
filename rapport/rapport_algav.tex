\documentclass[a4paper,12pt]{report}
%\documentclass[a4paper,10pt]{scrartcl}

\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
% \usepackage{hyperref}
\usepackage{tikz}
\usepackage[margin=0.75in]{geometry}
\usetikzlibrary{arrows}

\renewcommand{\chaptername}{}
\setcounter{chapter}{-1}

\tikzset{
  treenode/.style = {align=center, inner sep=0pt, text centered,
    font=\sffamily},
  arn_n/.style = {treenode, circle, draw=black, text width=2em},
  arn_x/.style = {treenode, rectangle, draw=black, text width=1.5em,
    minimum width=1.5em, minimum height=1.5em}
}

\title{\Huge Rapport \\ Projet ALGAV Trie \\ \large Implantation du Trie Hybride et du Patricia Trie}
\author{Amel Arkoub 3301571 \\ Ling-Chun SO 3414546}
\date{22 décembre 2017}

\pdfinfo{%
  /Title    ()
  /Author   ()
  /Creator  ()
  /Producer ()
  /Subject  ()
  /Keywords ()
}

\begin{document}
\maketitle

\tableofcontents
\newpage

\chapter{Introduction}
\section*{Présentation}
\paragraph*{}
Nous souhaitons représenter un dictionnaire de mots, c'est-à-dire implanter une structure de
données éfficace stockant des mots. Pour cela, nous allons nous servir de la structure de Trie.
Dans cette optique, nous proposons l'implantation de deux structures de tries concurrentes que sont le Trie Hybride
et le Patricia Trie. De cette implantation, une étude expérimentale sera analysées afin de mettre en exergue
les avantages et inconvénients de chacune de ces structures. Le langage choisit pour l'implantation de ces deux
structures est JAVA.

\section*{Trie}
Un Trie est une représentation arborescente d'un ensemble de clés en évitant de répéter les préfixes communs.

\section*{Trie Hybride}
Un Trie Hybride est un arbre ternaire dont chaque noeud contient un caractère et une valeur (non vide
lorsque le noeud représente une clé). Chaque noeud a 3 pointeurs: un lien Inf (resp. Eq, res. Sup) vers le sous
arbre dont le premier caractère est inférieur (resp. égal, resp. supérieur) à son caractère. Il permet en outre
de réduire le nombre de pointeurs vide par rapport à un R-Trie.

\section*{Patricia Trie}
Un Patricia Trie est un arbre dont le but est de réduire la taille des R-Trie tout en conservant une recherche
efficace. Pour ce faire, plutôt que chaque noeud interne permette de distinguer une lettre, il permet de distinguer
la plus longue sous-chaîne de lettres communes à plusieurs mots.

\chapter{Trie Hybride}
\section{Implantation}
\subsection{Structure}
Dans notre implantation JAVA, un Trie Hybride est un objet qui contient 5 éléments:
\begin{itemize}
 \item un char ``letter'', qui correspond à la lettre stockée.
 \item une valeur ``value'', qui correspond à la représentation de fin de mot (-1 le noeud n'est pas la fin
 d'un mot, sinon la valeur correspond à l'ordre d'ajout croissant).
 \item un pointeur vers un Trie Hybride ``fc'', ce Trie Hybride correpond au fils central, c'est-à-dire on parcours ce
 Trie Hybride si le caractère recherché au Trie Hybride courant est correct.
 \item un pointeur vers un Trie Hybride ``fg'', ce Trie Hybride correpond au fils gauche, c'est-à-dire on parcours ce
 Trie Hybride si le caractère recherché au Trie Hybride courant est plus petit dans l'ordre alphabétique.
 \item un pointeur vers un Trie Hybride ``fd'', ce Trie Hybride correpond au fils droit, c'est-à-dire on parcours ce
 Trie Hybride si le caractère recherché au Trie Hybride courant est plus grand dans l'ordre alphabétique.
\end{itemize}

\paragraph*{}
Voici une représentation ci-dessous du Trie Hybride résultant des l'ajouts successifs des mots:
\begin{itemize}
 \item don
 \item le
 \item a
 \item dort
\end{itemize}

\begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 6cm/#1,
  level distance = 2.5cm}]
\node [arn_n] {d \\ -1}
    child{ node [arn_n] {a \\ 2}}
    child{ node [arn_n] {o \\ -1}
	    child{ node [arn_x] {}}
            child{ node [arn_n] {n \\ 0} 
							child{ node [arn_n] {r \\ -1}
							      child{ node [arn_n] {t \\ 3}}
							}
							child{ node [arn_x] {}}
							child{ node [arn_x] {}}
            }
            child{ node [arn_x] {}}
		}
    child{ node [arn_n] {l \\ -1}
	    child{ node [arn_n] {e \\ 1}}
    }
; 
\end{tikzpicture}
\begin{figure}[!htbp]
\caption{Représentation d'un Trie Hybride}
\end{figure}

\section{Description des algorithmes}
\subsection{Algorithmes triviaux}
La plupart des algorithmes de l'implantation du Trie Hybride sont relativements triviaux, notamment
les fonctions:
\begin{itemize}
 \item Recherche(arbre, mot) $\rightarrow$ booléen
 \item ComptageMots(arbre) $\rightarrow$ entier
 \item ListeMots(arbre) $\rightarrow$ liste[mots]
 \item ComptageNil(arbre) $\rightarrow$ entier
 \item Hauteur(arbre) $\rightarrow$ entier
 \item ProfondeurMoyenne(arbre) $\rightarrow$ entier
 \item Prefixe(arbre) $\rightarrow$ entier
\end{itemize}
Elles correpondent pour la plupart d'un simple parcours de la structure du Trie Hybride, dont le traitement
dépend de la fonction.

\subsection{AjoutMot}
La fonction ajoutMot permet d'ajouter un mot dans le Trie Hybride et donc aussi la sa construction
dont la signature est: ajoutMot(mot, arbre) $\rightarrow$ void
Les étapes sont donc:
\begin{itemize}
 \item le cas d'arrêt lorsque le mot à été ajouté.
 \item si on est dans la racine qui est encore vide alors on ajoute le mot.
 \item si le mot est de longueur un, alors on verifie si le Trie Hybride courant correspond à la bonne lettre
 sinon on fait des appels récursifs sur le fils gauche ou droit.
 \item dans le cas général, on compare le caractère du mot et le caractère du Trie Hybride courant, si les lettres
 concordent alors on appel récursivement sur le fils central, s'ils sont différents on fait un appel récursif sur le
 fils gauche ou droit suivant l'ordre alphabétique des caractères.
\end{itemize}

\subsection{Suppression}
La fonction ajoutMot permet la suppression d'un mot dans le Trie Hybride et maintient le Trie Hybride cohérent en supprimant
les noeuds dont il n'existe pas de mot, la signature est: suppression(arbre, mot) $\rightarrow$ void
Les étapes sont donc:
\begin{itemize}
 \item si le Trie Hybride courant est un pointeur null alors on a un cas d'arrêt
 \item si le mot est réduit à une lettre alors on vérifie que le caractère du mot et du Trie Hybride courant, s'ils ne sont
 pas égaux alors on fait un appel récursif sur le fils gauche ou droit suivant la comparaison de l'ordre alphabétique des lettres
 \item dans le cas général, on compare le caractère du mot et le caractère du Trie Hybride courant, si les lettres
 concordent alors on appel récursivement sur le fils central, s'ils sont différents on fait un appel récursif sur le
 fils gauche ou droit suivant l'ordre alphabétique des caractères.
 \item on calcul le nombre de mots issus de chaque fils, s'il existe un fils dont le nombre de mots est égal à 0, alors on détruit
 le fils en question.
\end{itemize}


\section{Complexité}
\subsection{Recherche}
Pour la recherche d'un mot de \textit{L} caractères et un Trie Hybride de taille \textit{n}, 
en prenant la comparaison de caractère comme mesure, on obtient une complexité dans le cas général:
\begin{itemize}
 \item en $\Theta$(L), si \textit{L} < \textit{n};
 \item en $\Theta$(n) sinon.
\end{itemize}
Sinon on a une complexité en $\Theta$(n) dans le pire cas.

\subsection{Comptage Mots}
Le comptage de mots revient à faire un parcours de l'arbre en entier.
Soit un arbre de taille \textit{n}, en prenant la comparaison de la valeur du noeud comme mesure,
on a donc une complexité $\Theta$(n).

\subsection{Liste Mots}
La récupération des mots dans un Trie Hybride correspond aussi à un parcours de l'arbre en entier en gardant le \textit{préfixe}
en argument dans les appels de fonctions.
Soit un arbre de taille \textit{n}, en prenant la comparaison de la valeur du noeud comme mesure,
on a donc une complexité en $\Theta$(n).

\subsection{Comptage Nil}
Le comptage de pointeur vers null correspond à un parcours de tout les noeuds pour compter le nombre de fils null.
Soit un arbre de taille \textit{n}, en prenant la comparaison de la valeur du noeud comme mesure,
on a une complexité en $\Theta$(n) puisque pour \textit{n} noeuds, on a un nombre de comparaison $\le$ \textit{3n}.

\subsection{Hauteur}
La détermination de la hauteur du Trie Hybride est un parcours complet de l'arbre, en prenant l'existence de fils comme mesure
, on obtient une complexité en $\Theta$(n).

\subsection{Profondeur Moyenne}
La profondeur moyenne d'un Trie Hybride est un parcours jusqu'aux feuilles dont on ajoute la profondeur dans une liste et on effectue
une division. En prenant la comparaison d'existence de fils comme mesure, on obtient une complexité de $\Theta$(n).

\subsection{Préfixe}
La recherche du préfixe peut dans le pire des cas en $\Theta$(n) puisque le pire des cas est atteint lorsque le Trie Hybride
revient à être une ``liste chaînée'' et donc à hauteur \textit{h}=n.

\subsection{Suppression}
La suppression d'un mot est une recherche dans le Trie Hybride, ce qui correspond à une complexité en $\Theta$(n) comparaison
dans le pire cas, cependant il y a aussi 3 appels à la fonction comptageMots de complexité $\Theta$(n).
On a donc une complexité en $\mathcal{O}$($n^2$).

\chapter{Patricia Trie}
\section{Implantation}
\section{Complexité}
\subsection{Recherche}


\subsection{Comptage Mots}

\subsection{Liste Mots}

\subsection{Comptage Nil}

\subsection{Hauteur}

\subsection{Profondeur Moyenne}

\subsection{Préfixe}

\subsection{Suppression}

\chapter{Fonctions complexes}
\section{Implantation}
\subsection{Fusion de Patricia Trie}

\subsection{Conversion de Patricia Trie en Trie Hybride}

\subsection{Conversion de Trie Hybride en Patricia Trie}

\subsection{Rééquilibrage de Trie Hybride}
\paragraph{}
Après plusieurs ajouts successifs dans un Trie Hybride, ce dernier pourraitre être plutôt déséquilibré. Nous avons donc implantée
une fonction permettant d'identifier si un Trie Hybride est équilibré et le rééquilibrage de celui-ci dans le cas échéant.
Nous remarquons dans un Trie Hybride qu'il n'est pas modifiable dans la profondeur des fils centraux mais qu'il l'est, à
partir d'un noeud courant, pour ses fils gauche et droit. En effet, ceux-ci sont ``intervertibles'' entre eux, nous pouvons donc
considérer comme un équilibrage d'AVL dont le fils gauche et droit correspondent respectivement au fils gauche et droit d'un AVL.
La fonction checkBalance(arbre) $\rightarrow$ booléen, permet d'identifier si un Trie Hybride est équilibré ou non, celui-ci
calcul dans tout le Trie Hybride s'il existe un noeud dont le nombre de successions de fils gauche ou droit dans le fils gauche ou 
droit du noeud courant diffère de plus de 1. S'il diffère alors le Trie Hybride est déséquilibré.

\paragraph{}
La fonction de réequilibrage est balanceTrieHybride(arbre) $\rightarrow$ void, elle se décompose en ces étapes:
\begin{itemize}
 \item le cas de base si le Trie Hybride est null
 \item on calcul si le Trie Hybride est déjà équilibré, s'il est équilibré alors on récupère tout les fils centraux de la
 successions de fils gauche et droit du noeud courant et on effectue des appels recursifs sur ces fils
 \item on extrait la succession des fils gauche et droit du noeud courant et on effectue un tri dans l'ordre alphabétique
 \item on retire dans ces noeuds les liens fils gauche et droit
 \item on calcul le noeud qui sera au milieu, l'élément qui coupe en deux sous tableaux de taille égal
 \item étant donné que nous manipulons des pointeurs et ne possédant pas de pointeur sur le père, nous remplaçons le contenu
 dans l'ancien noeud courant par le nouveau noeud milieu et vice-versa
 \item on effectue un appel à la fonction splitting(arbre,arbre[],arbre[]), celui-ci permet pour un noeud courant d'attribuer le
 fils gauche et droit. le premier tableau correspond a l'ensemble des fils gauche que peut prendre le noeud courant et le second
 tableau correspond à l'ensemble des fils droit que peut prendre le noeud courant. Ainsi cette fonction récursive, calcul par
 dichotomie, les fils gauche et droit des noeuds.
 \item on récupère tout les fils centraux du chemin de fils gauche et droit pour faire des appels récursifs
\end{itemize}
Il est important de noter que le nombre maximal de noeuds d'un chemin de fils gauche et droit est majoré par une contante (26
pour les lettres de l'alphabet).

\section{Complexité}
\subsection{Fusion de Patricia Trie}

\subsection{Conversion de Patricia Trie en Trie Hybride}

\subsection{Conversion de Trie Hybride en Patricia Trie}

\subsection{Rééquilibrage de Trie Hybride}
\paragraph{checkBalance}
La fonction qui vérifie si un Trie Hybride équilibré, s'appui sur la fonction checkBalanceAux qui lui même utilise countLRNode.
Les complexités sont donc:
\begin{itemize}
 \item countLRNode est en $\Theta$(26) donc en $\Theta$(1), car le plus long chemin de fils gauche et droit est majoré par 26
 \item checkBalanceAux est donc aussi en $\Theta$(1), puiqu'il calcul pour le fils gauche et droit du noeud courant
 \item checkBalance est en $\Theta$($\log_{26}$(n)) donc en $\Theta$($\log_{}$(n)), puisqu'il fait appel à checkBalanceAux 
pour tout les noeuds sauf les noeuds du chemin de fils gauche et droit.
\end{itemize}

\paragraph{balanceTrieHybride}
De la même manière que checkBalance, la fonction balanceTrieHybride est en $\Theta$($\log_{}$(n)), puisque toutes les opérations
sont des opérations en $\Theta$(1) sauf pour les appels récursifs.

\chapter{Etude expérimentale}
\section{Temps de construction}
Nous avons calculé, le temps de construction des différentes implantations réalisées. Nous avons chargé avec un pas de 1000,
tout les mots contenu dans l'oeuvre de Shakespeare, en repartant d'un Trie vide à chaque pas.
\begin{figure}[!htbp]
\caption{Courbe du temps de calcul en fonction du nombre d'ajouts}
\end{figure}

\section{Temps d'ajout d'un mot}
Nous avons aussi calculé le temps d'ajout d'un mot dans des Tries qui avaient les oeuvres de Shakespeare déjà chargé, nous avons
ajouté des mots français de longueur croissante, dont le plus long mot est composé de 25 lettres.
\begin{figure}[!htbp]
\caption{Courbe du temps de calcul en fonction de la longueur du mot}
\end{figure}
\section{Temps de suppression}
Le temps de suppression en chargeant dans les Tries les oeuvres de Shakespeare et en supprimant un ensemble de mot avec un pas
de 1000.
\begin{figure}[!htbp]
\caption{Courbe du temps de calcul en fonction du nombre de suppression}
\end{figure}

\section{Profondeur moyenne des structures}
Cette étude de la profondeur des structures permet de mettre en évidence l'évolution de la profondeur moyenne des structures
suivant le nombre de mot contenu. Nous avons chargé les oeuvres de Shakespeare avec un pas de 1000 et en calculant la profondeur
moyenne entre ces ajouts.
\begin{figure}[!htbp]
\caption{Courbe de la profondeur moyenne en fonction du nombre d'ajouts}
\end{figure}
\section{Hauteur}
De la même manière que pour le calcul de la profondeur moyenne, nous avons chargé les oeuvres et Shakespeare avec un pas de 1000
et en calculant la hauteur entre ces ajouts.
\begin{figure}[!htbp]
\caption{Courbe de la hauteur en fonction du nombre d'ajouts}
\end{figure}

\end{document}
